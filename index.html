<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remove the app! (Instant Play)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.58/build/Tone.min.js"></script>
    <style>
        /* CSS Variables for Dynamic Background Control */
        :root {
            --bg-hue: 220; 
            --bg-saturation: 20%;
            --bg-lightness: 8%;
        }
        
        /* 1. Body tam ekranı kaplamalı */
        body {
            width: 100vw; 
            height: 100vh;
            margin: 0;
            padding: 0;
            
            /* HSL used for dynamic hue cycling */
            background: radial-gradient(circle at center, 
                hsl(var(--bg-hue), var(--bg-saturation), 10%) 0%, 
                #000000 100%);
            transition: background 0.5s ease-out; 
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Mobil gecikmeleri engeller */
        }

        /* 2. Ana düzenleyici (main-content) yüksekliği yönetmeli */
        .main-content {
             display: flex;
             flex-direction: column;
             height: 100%; /* Body'nin 100vh'ini kullan */
             width: 100%;
             padding-top: 1rem; /* pt-4 */
             padding-bottom: 1rem; /* pb-4 */
             box-sizing: border-box; /* Padding dahil boyutu hesapla */
        }

        #gameCanvas {
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2), 0 0 10px rgba(0, 255, 255, 0.4);
            border: 2px solid #00FFFF;
            transition: box-shadow 0.3s ease-out;
            cursor: pointer; 
        }
        .flow-active-shadow {
            box-shadow: 0 0 100px hsla(var(--bg-hue), 100%, 70%, 0.9), 0 0 30px hsla(var(--bg-hue), 100%, 80%, 1);
            border: 3px solid hsla(var(--bg-hue), 100%, 80%, 1) !important;
        }
        .full-screen-container {
             flex-grow: 1; 
             display: flex;
             align-items: center;
             justify-content: center;
             width: 100%;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Consolas', 'Monaco', 'monospace'],
                    },
                }
            }
        }
    </script>
</head>

<body class="overflow-hidden text-gray-100"> 

    <div class="main-content flex items-center justify-start"> 

        <div class="text-4xl font-extrabold mb-4 tracking-widest text-red-400 mx-auto">
            <span class="text-gray-500">REMOVE </span><span class="text-red-500">THE APP!</span>
        </div>

        <div class="grid grid-cols-4 gap-4 mb-4 p-4 bg-gray-900/70 backdrop-blur-md rounded-2xl shadow-2xl border border-cyan-800/50 w-full max-w-lg mx-auto">
            <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
                Score: <span id="score" class="text-yellow-300 font-extrabold text-xl font-mono">0</span>
            </div>
            <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
                Multiplier: <span id="multiplier" class="text-orange-400 font-extrabold text-xl font-mono">1</span>x
            </div>
            <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
                High: <span id="highScore" class="text-green-400 font-extrabold text-xl font-mono">0</span>
            </div>
            <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
                Orblets: <span id="orblets" class="text-yellow-300 font-extrabold text-xl font-mono">0</span>
            </div>
            <div class="col-span-4 text-sm font-medium text-center border-b border-gray-700/50 pb-1">
                Juice:
                <div class="w-full bg-gray-700 rounded-full h-2.5">
                    <div id="powerupBar" class="bg-purple-500 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
            <div id="statusMessage" class="col-span-4 text-sm font-medium text-center border-b border-gray-700/50 pb-1 text-cyan-400 transition duration-300">
                GET READY!
            </div>
        </div>
        
        <div id="canvasContainer" class="full-screen-container">
            <canvas id="gameCanvas" class="rounded-xl"></canvas>
        </div>

        <div class="mt-4 text-sm text-gray-500 mx-auto">
            <span class="font-bold text-yellow-400">Tip:</span> Jump power is proportional to your press duration.
        </div>
        
    </div> <script>
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const multiplierEl = document.getElementById('multiplier'); 
        const highScoreEl = document.getElementById('highScore');
        const statusMessageEl = document.getElementById('statusMessage');
        const canvasContainer = document.getElementById('canvasContainer'); 
        const powerupBarEl = document.getElementById('powerupBar'); 
        const orbletsEl = document.getElementById('orblets');

        // --- GAME SETTINGS ---
        const ORB_RADIUS = 15;
        const GRAVITY = 0.4;
        
        // --- PROPORTIONAL INPUT SETTINGS ---
        const MIN_LIFT = -3;   
        const MAX_LIFT = -13;  
        const MIN_DURATION_MS = 30; 
        const MAX_DURATION_MS = 200; 
        let pressStartTime = 0; 
        let isPressing = false; 

        // --- FLOW ZONE SETTINGS ---
        const BASE_ZONE_HEIGHT = 150;
        const MIN_ZONE_HEIGHT = 40; 
        const BASE_ZONE_SPEED = 0.03;
        const MAX_ZONE_SPEED = 0.08; 
        const ZONE_AMPLITUDE = 150;
        const COMBO_COLOR_CYCLE = 200; 
        const TIME_TICK_MS = 1000; 
        const MAX_ORBLETS = 30;
        const ORBLET_ATTRACTION_RADIUS = 150;
        const MAX_ORBLET_VELOCITY = 10; // New constant to limit orblet speed

        // --- GAME OBJECTS AND STATE ---
        let orb = { x: 0, y: 0, radius: ORB_RADIUS, velocityY: 0 };
        let flowZone = { y: 0, height: BASE_ZONE_HEIGHT, speed: BASE_ZONE_SPEED, time: 0 };
        let score = 0;
        let combo = 0;
        let isInFlow = false;
        let isAudioReady = false;
        let animationFrameId;
        let comboFlashRadius1 = 0; 
        let comboFlashRadius2 = 0; 
        let orblets = [];
        let powerupProgress = 0;
        const orbletsForPowerup = 10;
        let isSuperOrbActive = false;
        let superOrbTimer = 0;
        let activeEvent = null;
        let isOrbVacuumActive = false;

        // --- SCORING STATE ---
        let flowDurationMs = 0; 
        let scoreMultiplier = 1;

        // --- LOKAL YÜKSEK SKOR (LocalStorage) ---
        let highScore = 0;
        const LOCAL_HIGH_SCORE_KEY = 'flowGameHighScore'; 
        let totalOrblets = 0;
        const LOCAL_ORBLETS_KEY = 'flowGameOrblets';
        const LOCAL_SKIN_KEY = 'flowGameSkin';
        let currentSkin = '#FFFFFF';

        const skins = [
            { name: 'Default', price: 0, color: '#FFFFFF' },
            { name: 'Ruby', price: 100, color: '#FF0000' },
            { name: 'Emerald', price: 150, color: '#00FF00' },
            { name: 'Sapphire', price: 200, color: '#0000FF' },
        ];
        
        // --- TONE.JS AUDIO OBJECTS ---
        let flowPad, missEffect, pressFeedback;
        let currentFlowNote = 'C4'; 

        // --- Timing Variables for accurate scoring ---
        let lastTimestamp = performance.now();


        // =================================================================
        //                 AUDIO (TONE.JS) INTEGRATION
        // =================================================================

        function setupAudio() {
            if (typeof Tone === 'undefined') {
                return;
            }

            flowPad = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.5, decay: 0.1, sustain: 1.0, release: 0.5 },
                volume: -15, 
            }).toDestination();
            
            missEffect = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 3,
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.5 },
                volume: -8
            }).toDestination();

            pressFeedback = new Tone.PluckSynth({
                attackNoise: 1,
                dampening: 2000,
                resonance: 0.9,
                volume: 0, 
            }).toDestination();

            isAudioReady = true;
        }

        async function startAudioContext() {
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                } catch (e) {
                    // Mobil kısıtlamalar nedeniyle hata verebilir, ama oyunu durdurmaz.
                    console.warn("AudioContext could not start automatically. User interaction needed on mobile.", e);
                }
            }
        }

        // =================================================================
        //                 LOKAL SKOR KAYIT/YÜKLEME (LocalStorage)
        // =================================================================

        function loadHighScore() {
            try {
                const storedScore = localStorage.getItem(LOCAL_HIGH_SCORE_KEY);
                highScore = storedScore ? parseInt(storedScore, 10) : 0;
            } catch (error) {
                console.error("Local High score could not be loaded:", error);
                highScore = 0;
            }
            highScoreEl.textContent = highScore.toLocaleString();
        }

        function saveHighScore(newScore) {
            if (newScore <= highScore) return;

            try {
                localStorage.setItem(LOCAL_HIGH_SCORE_KEY, newScore);
                highScore = newScore;

                highScoreEl.textContent = highScore.toLocaleString();
                statusMessageEl.textContent = 'NEW RECORD!';
                statusMessageEl.classList.remove('text-red-400', 'text-gray-400', 'text-cyan-400');
                statusMessageEl.classList.add('text-green-400', 'font-bold');

            } catch (error) {
                console.error("Local High score could not be saved:", error);
            }
        }

        function checkAndSaveScore() {
            if (score > highScore) {
                saveHighScore(score);
            }
        }

        function loadTotalOrblets() {
            try {
                const storedOrblets = localStorage.getItem(LOCAL_ORBLETS_KEY);
                totalOrblets = storedOrblets ? parseInt(storedOrblets, 10) : 0;
            } catch (error) {
                console.error("Local Orblets could not be loaded:", error);
                totalOrblets = 0;
            }
            orbletsEl.textContent = totalOrblets.toLocaleString();
        }

        function saveTotalOrblets() {
            try {
                localStorage.setItem(LOCAL_ORBLETS_KEY, totalOrblets);
            } catch (error) {
                console.error("Local Orblets could not be saved:", error);
            }
        }

        function populateSkinsMenu() {
            const skinsContainer = document.getElementById('skinsContainer');
            skinsContainer.innerHTML = '';
            skins.forEach(skin => {
                const skinEl = document.createElement('div');
                skinEl.className = 'p-4 rounded-lg cursor-pointer';
                skinEl.style.backgroundColor = skin.color;
                skinEl.addEventListener('click', () => purchaseSkin(skin));
                skinsContainer.appendChild(skinEl);
            });
        }

        function purchaseSkin(skin) {
            if (totalOrblets >= skin.price) {
                totalOrblets -= skin.price;
                currentSkin = skin.color;
                saveTotalOrblets();
                localStorage.setItem(LOCAL_SKIN_KEY, currentSkin);
                orbletsEl.textContent = totalOrblets.toLocaleString();
                document.getElementById('closeSkinsMenu').click();
            } else {
                alert("You don't have enough orblets to buy this skin!");
            }
        }

        function loadSkin() {
            const savedSkin = localStorage.getItem(LOCAL_SKIN_KEY);
            if (savedSkin) {
                currentSkin = savedSkin;
            }
        }
        function spawnOrblet(force = false, isShower = false) {
            if (orblets.length >= MAX_ORBLETS) return;

            // Sporadic shower check - SADECE normal spawn'da kontrol et
            if (!force && !isShower && Math.random() < 0.1) { 
                startOrbletShower();
                return; // Shower başlattıktan sonra return et
            }

            const ORBLET_RADIUS = 5;
            let orblet = {
                x: Math.random() * (canvas.width - ORBLET_RADIUS * 2) + ORBLET_RADIUS,
                y: isShower ? -ORBLET_RADIUS : Math.random() * (canvas.height - ORBLET_RADIUS * 2) + ORBLET_RADIUS,
                radius: ORBLET_RADIUS,
                velocityX: 0,
                velocityY: isShower ? 2 + Math.random() * 3 : 0
            };
            orblets.push(orblet);
        }

        function startOrbletShower() {
            // Shower için orblet sayısını sınırla
            const showerCount = Math.min(15, MAX_ORBLETS - orblets.length);
            
            for (let i = 0; i < showerCount; i++) {
                const ORBLET_RADIUS = 5;
                // Doğrudan oluştur, spawnOrblet'i çağırma (sonsuz döngü önlenir)
                let orblet = {
                    x: Math.random() * (canvas.width - ORBLET_RADIUS * 2) + ORBLET_RADIUS,
                    y: -ORBLET_RADIUS - (i * 10), // Her birini biraz daha yukarıdan başlat
                    radius: ORBLET_RADIUS,
                    velocityX: (Math.random() - 0.5) * 2, // Hafif yatay hareket
                    velocityY: 2 + Math.random() * 3
                };
                orblets.push(orblet);
            }
        }

        function startOrbletShower() {
            // Shower için orblet sayısını sınırla
            const showerCount = Math.min(15, MAX_ORBLETS - orblets.length);
            
            for (let i = 0; i < showerCount; i++) {
                const ORBLET_RADIUS = 5;
                // Doğrudan oluştur, spawnOrblet'i çağırma (sonsuz döngü önlenir)
                let orblet = {
                    x: Math.random() * (canvas.width - ORBLET_RADIUS * 2) + ORBLET_RADIUS,
                    y: -ORBLET_RADIUS - (i * 10), // Her birini biraz daha yukarıdan başlat
                    radius: ORBLET_RADIUS,
                    velocityX: (Math.random() - 0.5) * 2, // Hafif yatay hareket
                    velocityY: 2 + Math.random() * 3
                };
                orblets.push(orblet);
            }
        }

        // =================================================================
        //                 PROPORTIONAL INPUT LOGIC
        // =================================================================

        function handlePressStart(e) {
             if (!animationFrameId) return; 
            if (isPressing) return;

            // Eğer AudioContext başlamadıysa, ilk tıklamayı ses bağlamını başlatmak için kullan
            if (Tone.context.state !== 'running' && isAudioReady) {
                startAudioContext();
            }

            if (e.code === 'Space' || e.type === 'touchstart' || e.type === 'mousedown') {
                isPressing = true;
                pressStartTime = performance.now();
                e.preventDefault(); 
            }
        }

        function handlePressEnd(e) {
            if (!animationFrameId || !isPressing) return;
            
            if (e.code === 'Space' || e.type === 'touchend' || e.type === 'mouseup') {
                const pressDuration = performance.now() - pressStartTime;

                let durationFactor = Math.min(1, 
                    Math.max(0, 
                        (pressDuration - MIN_DURATION_MS) / (MAX_DURATION_MS - MIN_DURATION_MS)
                    )
                );

                if (activeEvent === 'inversion') {
                    durationFactor = 1 - durationFactor;
                }

                const liftForce = MIN_LIFT + durationFactor * (MAX_LIFT - MIN_LIFT);

                orb.velocityY = liftForce;

                isPressing = false;
                e.preventDefault(); 
                
                // Instant feedback sound
                if (isAudioReady && Tone.context.state === 'running') {
                    pressFeedback.triggerAttackRelease("G6", "64n"); 
                }

                if (liftForce < MIN_LIFT) {
                    navigator.vibrate?.(50);
                }
            }
        }


        // --- GAME LOOP, UPDATE, AND DRAW CODE ---

        function resizeCanvas() {
            const containerRect = canvasContainer.getBoundingClientRect();
            
            const padding = 10; 
            const containerWidth = containerRect.width - padding * 2;
            const containerHeight = containerRect.height - padding * 2;
            
            const aspectRatio = 400 / 600; 
            
            let maxWidth = containerWidth;
            let maxHeight = containerHeight;
            
            if (maxWidth / maxHeight > aspectRatio) {
                maxWidth = maxHeight * aspectRatio;
            } else {
                maxHeight = maxWidth / aspectRatio;
            }
            
            canvas.width = Math.floor(maxWidth);
            canvas.height = Math.floor(maxHeight);

            orb.x = canvas.width / 2;
            orb.y = canvas.height - 50;
        }

        /**
         * OYUNU KOŞULSUZ BAŞLATAN FONKSİYON
         */
        function startGame() {
            // Sesi başlatmayı dene
            if (isAudioReady) {
                startAudioContext();
            }
            
            lastTimestamp = performance.now(); 
            
            // Oyun döngüsünü başlat
            if (!animationFrameId) {
                gameLoop();
                statusMessageEl.textContent = 'CATCH THE RHYTHM!';
                statusMessageEl.classList.remove('text-gray-400');
                statusMessageEl.classList.add('text-cyan-400');
                setInterval(spawnOrblet, 3000);
            }
        }

        function update() {
            const currentTimestamp = performance.now();
            const deltaTime = currentTimestamp - lastTimestamp;
            lastTimestamp = currentTimestamp;

            // Handle Super Orb Timer
            if (isSuperOrbActive) {
                superOrbTimer -= deltaTime;
                if (superOrbTimer <= 0) {
                    isSuperOrbActive = false;
                    orb.radius = ORB_RADIUS; // Reset orb size
                    statusMessageEl.textContent = 'GET READY!';
                    statusMessageEl.classList.remove('text-yellow-400');
                }
            }

            // 1. Orb Physics
            let currentGravity = GRAVITY;
            if (activeEvent === 'slowMo') {
                currentGravity /= 2;
            }
            orb.velocityY += currentGravity;
            orb.y += orb.velocityY;

            // 2. Screen Boundaries
            if (orb.y + orb.radius > canvas.height) {
                orb.y = canvas.height - orb.radius;
                orb.velocityY = 0;
            }
            if (orb.y - orb.radius < 0) {
                orb.y = 0 + orb.radius;
                orb.velocityY = 0;
            }

            // 3. Flow Zone Movement
            let currentSpeed = flowZone.speed;
            if (activeEvent === 'slowMo') {
                currentSpeed /= 2;
            }
            flowZone.time += currentSpeed;
            const zoneCenter = (canvas.height / 2) + (Math.sin(flowZone.time) * ZONE_AMPLITUDE);
            flowZone.y = zoneCenter - (flowZone.height / 2); 
            
            if (flowZone.y < 0) flowZone.y = 0;
            if (flowZone.y + flowZone.height > canvas.height) flowZone.y = canvas.height - flowZone.height;

            // 4. "FLOW" CHECK
            const topOfOrb = orb.y - orb.radius;
            const bottomOfOrb = orb.y + orb.radius;
            const topOfZone = flowZone.y;
            const bottomOfZone = flowZone.y + flowZone.height;

            // 5. Orblet Physics, Attraction, and Collection (Consolidated Loop)
            for (let i = orblets.length - 1; i >= 0; i--) {
                const orblet = orblets[i];

                // Apply attraction force if active
                if (isSuperOrbActive || isOrbVacuumActive) {
                    const distanceX = orb.x - orblet.x;
                    const distanceY = orb.y - orblet.y;
                    const distance = Math.hypot(distanceX, distanceY);

                    if (distance > 1 && distance < ORBLET_ATTRACTION_RADIUS) {
                        const normalizedX = distanceX / distance;
                        const normalizedY = distanceY / distance;
                        // Attraction strength that slightly decays with distance
                        const attractionStrength = 0.2 * (1 - (distance / ORBLET_ATTRACTION_RADIUS) * 0.8); 

                        orblet.velocityX += normalizedX * attractionStrength;
                        orblet.velocityY += normalizedY * attractionStrength;
                    }
                }

                // Update orblet position
                orblet.x += orblet.velocityX;
                orblet.y += orblet.velocityY;

                // Apply friction
                orblet.velocityX *= 0.95;
                orblet.velocityY *= 0.95;

                // Cap orblet velocity
                orblet.velocityX = Math.max(-MAX_ORBLET_VELOCITY, Math.min(orblet.velocityX, MAX_ORBLET_VELOCITY));
                orblet.velocityY = Math.max(-MAX_ORBLET_VELOCITY, Math.min(orblet.velocityY, MAX_ORBLET_VELOCITY));

                // Despawn logic
                if (orblet.y > canvas.height + orblet.radius || 
                    orblet.y < -orblet.radius ||
                    orblet.x > canvas.width + orblet.radius ||
                    orblet.x < -orblet.radius) {
                    orblets.splice(i, 1);
                    continue; // Skip collision check for despawned orblet
                }

                // Collision detection and collection
                const distanceToOrb = Math.hypot(orb.x - orblet.x, orb.y - orblet.y);
                if (distanceToOrb < orb.radius + orblet.radius) {
                    orblets.splice(i, 1);
                    score += 100;
                    totalOrblets++;
                    orbletsEl.textContent = totalOrblets.toLocaleString();
                    saveTotalOrblets();
                    if (isAudioReady && Tone.context.state === 'running') {
                        pressFeedback.triggerAttackRelease("C7", "32n");
                    }

                    powerupProgress++;
                    const powerupPercentage = (powerupProgress / orbletsForPowerup) * 100;
                    powerupBarEl.style.width = `${powerupPercentage}%`;

                    if (powerupProgress >= orbletsForPowerup) {
                        if (isSuperOrbActive) {
                            superOrbTimer += 3000; // Extend duration by 3 seconds
                            statusMessageEl.textContent = 'SUPER ORB EXTENDED!';
                            statusMessageEl.classList.add('text-yellow-400');
                        } else {
                            isSuperOrbActive = true;
                            superOrbTimer = 5000; // Initial 5 seconds
                            statusMessageEl.textContent = 'SUPER ORB ACTIVATED!';
                            statusMessageEl.classList.add('text-yellow-400');
                        }
                        powerupProgress = 0;
                        powerupBarEl.style.width = '0%';
                    }
                }
            }

            const oldMultiplier = scoreMultiplier;
            const oldCombo = combo;

            if (topOfOrb >= topOfZone && bottomOfOrb <= bottomOfZone) {
                // IN FLOW
                if (!isInFlow) {
                    isInFlow = true;
                    flowDurationMs = 0; 
                    scoreMultiplier = 1;
                    if(isAudioReady && Tone.context.state === 'running') flowPad.triggerAttack(currentFlowNote); 

                    statusMessageEl.textContent = 'FLOW!'; 
                    statusMessageEl.classList.add('text-cyan-400', 'font-bold');
                    statusMessageEl.classList.remove('text-red-400', 'text-gray-400', 'text-green-400');
                    canvas.classList.add('flow-active-shadow'); 
                }
                
                // NEW SCORING: Time-Based Multiplier
                flowDurationMs += deltaTime;
                const secondsInFlow = Math.floor(flowDurationMs / TIME_TICK_MS);
                
                scoreMultiplier = 1 + (secondsInFlow * 2);

                if (activeEvent === 'narrowZone') {
                    scoreMultiplier *= 2;
                }

                score += scoreMultiplier * (deltaTime / 16.66); 
                
                combo++;
                
                if (combo === 100 && activeEvent === null) {
                    activeEvent = 'slowMo';
                    statusMessageEl.textContent = 'SLOW MO!';
                    statusMessageEl.classList.add('text-blue-400');
                    setTimeout(() => {
                        activeEvent = null;
                        statusMessageEl.textContent = 'GET READY!';
                        statusMessageEl.classList.remove('text-blue-400');
                    }, 5000);
                }

                if (combo === 250 && activeEvent === null) {
                    activeEvent = 'narrowZone';
                    statusMessageEl.textContent = 'NARROW ZONE!';
                    statusMessageEl.classList.add('text-orange-400');
                    setTimeout(() => {
                        activeEvent = null;
                        statusMessageEl.textContent = 'GET READY!';
                        statusMessageEl.classList.remove('text-orange-400');
                    }, 15000);
                }

                if (combo === 300 && activeEvent === null) {
                    activeEvent = 'inversion';
                    statusMessageEl.textContent = 'INVERSION!';
                    statusMessageEl.classList.add('text-yellow-400');
                    setTimeout(() => {
                        activeEvent = null;
                        statusMessageEl.textContent = 'GET READY!';
                        statusMessageEl.classList.remove('text-yellow-400');
                    }, 10000);
                }

                if (scoreMultiplier > oldMultiplier && isAudioReady && Tone.context.state === 'running') {
                    missEffect.triggerAttackRelease("E5", "16n", Tone.now(), 0.5); 
                }

                if (combo % 50 === 0 && combo !== 0 && oldCombo < combo) {
                    comboFlashRadius1 = 10; 
                    comboFlashRadius2 = 1; 
                    if (isAudioReady && Tone.context.state === 'running') {
                        flowPad.triggerAttackRelease("A5", "16n"); 
                    }
                    isOrbVacuumActive = true;
                    setTimeout(() => {
                        isOrbVacuumActive = false;
                    }, 3000);
                }
                
                // Dynamic Difficulty
                flowZone.speed = Math.min(MAX_ZONE_SPEED, BASE_ZONE_SPEED + (combo * 0.0001));
                flowZone.height = Math.max(MIN_ZONE_HEIGHT, BASE_ZONE_HEIGHT - (combo * 0.05));
                if (activeEvent === 'narrowZone') {
                    flowZone.height /= 2;
                }
                
                // Dynamic Color Cycling & Pitch Modulation
                const baseHue = 180; 
                let hueOffset = (combo % COMBO_COLOR_CYCLE) * (360 / COMBO_COLOR_CYCLE);
                let dynamicHue = (baseHue + hueOffset) % 360;
                
                const minMidi = 60; 
                const maxMidi = 74; 
                const pitchRange = maxMidi - minMidi;
                const maxComboForFullPitch = 300;
                
                let targetMidi = minMidi + Math.min(maxComboForFullPitch, combo) * (pitchRange / maxComboForFullPitch);
                targetMidi = Math.round(targetMidi);
                
                const targetNote = Tone.Midi(targetMidi).toNote();
                
                if (targetNote !== currentFlowNote && isAudioReady && Tone.context.state === 'running') {
                    currentFlowNote = targetNote;
                    flowPad.frequency.rampTo(currentFlowNote, 0.2); 
                }

                const maxComboVisual = 300;
                const saturation = Math.min(100, 30 + (combo / maxComboVisual) * 70); 
                const lightness = Math.max(5, 12 - (combo / maxComboVisual) * 7); 

                document.documentElement.style.setProperty('--bg-hue', dynamicHue);
                document.documentElement.style.setProperty('--bg-saturation', `${saturation}%`);
                document.documentElement.style.setProperty('--bg-lightness', `${lightness}%`);
                
            } else {
                // OUT OF FLOW
                if (isInFlow) {
                    isInFlow = false;
                    checkAndSaveScore(); 
                    combo = 0; 
                    flowDurationMs = 0;
                    scoreMultiplier = 1; // Reset Multiplier
                    comboFlashRadius1 = 0;
                    comboFlashRadius2 = 0;
                    
                    if(isAudioReady && Tone.context.state === 'running') {
                        flowPad.triggerRelease();
                        missEffect.triggerAttackRelease("C2", "8n"); 
                    }
                    
                    currentFlowNote = 'C4'; 
                    flowZone.speed = BASE_ZONE_SPEED;
                    flowZone.height = BASE_ZONE_HEIGHT;
                    
                    statusMessageEl.textContent = 'Rhythm Lost'; 
                    statusMessageEl.classList.remove('text-cyan-400', 'font-bold', 'text-green-400');
                    statusMessageEl.classList.add('text-red-400');
                    canvas.classList.remove('flow-active-shadow');

                    // Reset colors to original state
                    document.documentElement.style.setProperty('--bg-hue', 220); 
                    document.documentElement.style.setProperty('--bg-saturation', '20%');
                    document.documentElement.style.setProperty('--bg-lightness', '8%');

                    setTimeout(() => {
                        if (!isInFlow && score <= highScore) { 
                            statusMessageEl.textContent = 'GET READY!'; 
                            statusMessageEl.classList.remove('text-red-400');
                            statusMessageEl.classList.add('text-cyan-400');
                        }
                    }, 1500);
                }
            }
            
            // Combo Flash Animation
            if (comboFlashRadius1 > 0) {
                comboFlashRadius1 += 8; 
                comboFlashRadius2 += 5; 
                if (comboFlashRadius1 > canvas.width * 0.9) {
                    comboFlashRadius1 = 0;
                    comboFlashRadius2 = 0;
                }
            }

            // Update Score/Combo UI
            scoreEl.textContent = Math.floor(score).toLocaleString(); 
            multiplierEl.textContent = scoreMultiplier; 
        }

        function draw() {
            const flowHue = parseInt(document.documentElement.style.getPropertyValue('--bg-hue')) || 180;
            const isFlowing = isInFlow;
            const currentCombo = combo;
            
            // 1. Ekranı Temizle (Clean Clear)
            ctx.fillStyle = '#0f0c1c'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.globalCompositeOperation = 'lighter'; 

            // Combo Flash Ring
            if (comboFlashRadius1 > 0) {
                const maxRadius = canvas.width * 0.9;
                
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, comboFlashRadius1, 0, Math.PI * 2);
                const alpha1 = 1 - (comboFlashRadius1 / maxRadius);
                ctx.strokeStyle = `hsla(${flowHue}, 100%, 75%, ${alpha1 * 0.9})`; 
                ctx.lineWidth = 6;
                ctx.stroke();
                ctx.closePath();

                if (comboFlashRadius2 > 0) {
                    ctx.beginPath();
                    ctx.arc(orb.x, orb.y, comboFlashRadius2, 0, Math.PI * 2);
                    const alpha2 = 1 - (comboFlashRadius2 / maxRadius);
                    ctx.strokeStyle = `hsla(${flowHue}, 100%, 50%, ${alpha2 * 0.5})`; 
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.closePath();
                }
            }

            // 2. Draw Flow Zone
            ctx.fillStyle = `hsla(${flowHue}, ${isFlowing ? 90 : 50}%, ${isFlowing ? 30 : 20}%, 0.15)`;
            ctx.fillRect(0, flowZone.y - 5, canvas.width, flowZone.height + 10);

            ctx.fillStyle = `hsla(${flowHue}, ${isFlowing ? 100 : 60}%, ${isFlowing ? 40 : 25}%, 0.25)`; 
            ctx.fillRect(0, flowZone.y, canvas.width, flowZone.height);

            ctx.fillStyle = `hsla(${flowHue}, ${isFlowing ? 100 : 70}%, ${isFlowing ? 50 : 35}%, 0.4)`; 
            ctx.fillRect(0, flowZone.y + flowZone.height * 0.15, canvas.width, flowZone.height * 0.7);

            ctx.strokeStyle = `hsla(${flowHue}, ${isFlowing ? 100 : 70}%, ${isFlowing ? 65 : 45}%, 1)`;
            ctx.lineWidth = isFlowing ? 2 : 1;
            ctx.strokeRect(0, flowZone.y, canvas.width, flowZone.height);
            ctx.lineWidth = 1; 

            // 3. Draw Orblets
            ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
            orblets.forEach(orblet => {
                ctx.beginPath();
                ctx.arc(orblet.x, orblet.y, orblet.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // 4. Draw Orb 
            const orbColor = isFlowing ? `hsl(${flowHue}, 100%, 75%)` : currentSkin;
            const orbGlowColor = isFlowing ? `hsla(${flowHue}, 100%, 70%, 1)` : 'rgba(255, 255, 255, 0.5)';
            
            if (isSuperOrbActive) {
                const pulse = Math.sin(performance.now() / 100) * 5;
                orb.radius = ORB_RADIUS * 1.5 + pulse;
                ctx.shadowBlur = 35;
                ctx.shadowColor = 'rgba(255, 255, 0, 1)';
            } else {
                orb.radius = ORB_RADIUS;
                ctx.shadowBlur = isFlowing ? 25 : 8;
                ctx.shadowColor = orbGlowColor;
            }
            
            ctx.beginPath();
            ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
            ctx.fillStyle = isSuperOrbActive ? 'rgba(255, 255, 0, 1)' : orbColor;
            ctx.fill();
            ctx.shadowBlur = 0; 
            ctx.closePath();
            
            if (isOrbVacuumActive) {
                const auraRadius = orb.radius + 15 + Math.sin(performance.now() / 100) * 5;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, auraRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${flowHue}, 100%, 75%, 0.5)`;
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.closePath();
            }

            if (isFlowing) {
                 ctx.beginPath();
                 ctx.arc(orb.x, orb.y, orb.radius * 0.6, 0, Math.PI * 2);
                 ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; 
                 ctx.fill();
                 ctx.closePath();
            }

            if (isFlowing) {
                const auraRadius = orb.radius + 5 + Math.min(10, currentCombo / 30);
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, auraRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${flowHue}, 100%, 60%, ${0.3 + Math.min(0.7, currentCombo/100)})`;
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.closePath();
            }

            ctx.globalCompositeOperation = 'source-over';
        }

        // --- GAME LOOP ---
        function gameLoop() {
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // =================================================================
        //                       INITIALIZATION AND EVENT LISTENERS
        // =================================================================

        window.onload = function() {
            loadHighScore(); 
            loadTotalOrblets();
            loadSkin();
            populateSkinsMenu();
            setupAudio();
            resizeCanvas();
            
            // OYUN DİREKT BAŞLIYOR!
            startGame(); 

            // Olay dinleyicilerini kur
            window.addEventListener('keydown', handlePressStart);
            window.addEventListener('keyup', handlePressEnd);

            canvas.addEventListener('mousedown', handlePressStart);
            window.addEventListener('mouseup', handlePressEnd);
            
            canvas.addEventListener('touchstart', handlePressStart);
            window.addEventListener('touchend', handlePressEnd);

            window.addEventListener('resize', resizeCanvas);

            document.getElementById('orblets').addEventListener('click', () => {
                document.getElementById('skinsMenu').classList.remove('hidden');
            });

            document.getElementById('closeSkinsMenu').addEventListener('click', () => {
                document.getElementById('skinsMenu').classList.add('hidden');
            });
        };

    </script>

    <div id="skinsMenu" class="hidden absolute top-0 left-0 w-full h-full bg-black bg-opacity-50 flex items-center justify-center">
        <div class="bg-gray-800 p-8 rounded-lg shadow-lg text-white">
            <h2 class="text-2xl font-bold mb-4">Unlock New Orb Skins</h2>
            <div id="skinsContainer" class="grid grid-cols-3 gap-4">
                <!-- Skins will be dynamically added here -->
            </div>
            <button id="closeSkinsMenu" class="mt-4 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded">
                Close
            </button>
        </div>
    </div>
</body>
</html>
