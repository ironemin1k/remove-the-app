<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remove the app! (Instant Play)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.58/build/Tone.min.js"></script>
    <style>
        /* CSS Variables for Dynamic Background Control */
        :root {
            --bg-hue: 220; 
            --bg-saturation: 20%;
            --bg-lightness: 8%;
        }
        
        /* 1. Body tam ekranı kaplamalı */
        body {
            width: 100vw; 
            height: 100vh;
            margin: 0;
            padding: 0;
            
            /* HSL used for dynamic hue cycling */
            background: radial-gradient(circle at center, 
                hsl(var(--bg-hue), var(--bg-saturation), 10%) 0%, 
                #000000 100%);
            transition: background 0.5s ease-out; 
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Mobil gecikmeleri engeller */
        }

        /* 2. Ana düzenleyici (main-content) yüksekliği yönetmeli */
        .main-content {
             display: flex;
             flex-direction: column;
             height: 100%; /* Body'nin 100vh'ini kullan */
             width: 100%;
             padding-top: 1rem; /* pt-4 */
             padding-bottom: 1rem; /* pb-4 */
             box-sizing: border-box; /* Padding dahil boyutu hesapla */
        }

        #gameCanvas {
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2), 0 0 10px rgba(0, 255, 255, 0.4);
            border: 2px solid #00FFFF;
            transition: box-shadow 0.3s ease-out;
            cursor: pointer; 
        }
        .flow-active-shadow {
            box-shadow: 0 0 100px hsla(var(--bg-hue), 100%, 70%, 0.9), 0 0 30px hsla(var(--bg-hue), 100%, 80%, 1);
            border: 3px solid hsla(var(--bg-hue), 100%, 80%, 1) !important;
        }
        .full-screen-container {
             flex-grow: 1; 
             display: flex;
             align-items: center;
             justify-content: center;
             width: 100%;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Consolas', 'Monaco', 'monospace'],
                    },
                }
            }
        }
    </script>
</head>

<body class="overflow-hidden text-gray-100"> 

    <div class="main-content flex items-center justify-start"> 

        <div class="text-4xl font-extrabold mb-4 tracking-widest text-red-400 mx-auto">
            <span class="text-gray-500">REMOVE </span><span class="text-red-500">THE APP!</span>
        </div>

        <div class="grid grid-cols-3 gap-4 mb-4 p-4 bg-gray-900/70 backdrop-blur-md rounded-2xl shadow-2xl border border-cyan-800/50 w-full max-w-lg mx-auto">
            <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
                Score: <span id="score" class="text-yellow-300 font-extrabold text-xl font-mono">0</span>
            </div>
            <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
                Multiplier: <span id="multiplier" class="text-orange-400 font-extrabold text-xl font-mono">1</span>x
            </div>
            <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
                High: <span id="highScore" class="text-green-400 font-extrabold text-xl font-mono">0</span>
            </div>
            <div id="statusMessage" class="col-span-3 text-sm font-medium text-center border-b border-gray-700/50 pb-1 text-cyan-400 transition duration-300">
                GET READY!
            </div>
        </div>
        
        <div id="canvasContainer" class="full-screen-container">
            <canvas id="gameCanvas" class="rounded-xl"></canvas>
        </div>

        <div class="mt-4 text-sm text-gray-500 mx-auto">
            <span class="font-bold text-yellow-400">Tip:</span> Jump power is proportional to your press duration.
        </div>
        
    </div> <script>
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const multiplierEl = document.getElementById('multiplier'); 
        const highScoreEl = document.getElementById('highScore');
        const statusMessageEl = document.getElementById('statusMessage');
        const canvasContainer = document.getElementById('canvasContainer'); 

        // --- GAME SETTINGS ---
        const ORB_RADIUS = 15;
        const GRAVITY = 0.4;
        
        // --- PROPORTIONAL INPUT SETTINGS ---
        const MIN_LIFT = -3;   
        const MAX_LIFT = -13;  
        const MIN_DURATION_MS = 30; 
        const MAX_DURATION_MS = 200; 
        let pressStartTime = 0; 
        let isPressing = false; 

        // --- FLOW ZONE SETTINGS ---
        const BASE_ZONE_HEIGHT = 150;
        const MIN_ZONE_HEIGHT = 40; 
        const BASE_ZONE_SPEED = 0.03;
        const MAX_ZONE_SPEED = 0.08; 
        const ZONE_AMPLITUDE = 150;
        const COMBO_COLOR_CYCLE = 200; 
        const TIME_TICK_MS = 1000; 

        // --- GAME OBJECTS AND STATE ---
        let orb = { x: 0, y: 0, radius: ORB_RADIUS, velocityY: 0 };
        let flowZone = { y: 0, height: BASE_ZONE_HEIGHT, speed: BASE_ZONE_SPEED, time: 0 };
        let score = 0;
        let combo = 0;
        let isInFlow = false;
        let isAudioReady = false;
        let animationFrameId;
        let comboFlashRadius1 = 0; 
        let comboFlashRadius2 = 0; 

        // --- SCORING STATE ---
        let flowDurationMs = 0; 
        let scoreMultiplier = 1;

        // --- LOKAL YÜKSEK SKOR (LocalStorage) ---
        let highScore = 0;
        const LOCAL_HIGH_SCORE_KEY = 'flowGameHighScore'; 
        
        // --- TONE.JS AUDIO OBJECTS ---
        let flowPad, missEffect, pressFeedback;
        let currentFlowNote = 'C4'; 

        // --- Timing Variables for accurate scoring ---
        let lastTimestamp = performance.now();


        // =================================================================
        //                 AUDIO (TONE.JS) INTEGRATION
        // =================================================================

        function setupAudio() {
            if (typeof Tone === 'undefined') {
                return;
            }

            flowPad = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.5, decay: 0.1, sustain: 1.0, release: 0.5 },
                volume: -15, 
            }).toDestination();
            
            missEffect = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 3,
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.5 },
                volume: -8
            }).toDestination();

            pressFeedback = new Tone.PluckSynth({
                attackNoise: 1,
                dampening: 2000,
                resonance: 0.9,
                volume: 0, 
            }).toDestination();

            isAudioReady = true;
        }

        async function startAudioContext() {
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                } catch (e) {
                    // Mobil kısıtlamalar nedeniyle hata verebilir, ama oyunu durdurmaz.
                    console.warn("AudioContext could not start automatically. User interaction needed on mobile.", e);
                }
            }
        }

        // =================================================================
        //                 LOKAL SKOR KAYIT/YÜKLEME (LocalStorage)
        // =================================================================

        function loadHighScore() {
            try {
                const storedScore = localStorage.getItem(LOCAL_HIGH_SCORE_KEY);
                highScore = storedScore ? parseInt(storedScore, 10) : 0;
            } catch (error) {
                console.error("Local High score could not be loaded:", error);
                highScore = 0;
            }
            highScoreEl.textContent = highScore.toLocaleString();
        }

        function saveHighScore(newScore) {
            if (newScore <= highScore) return;

            try {
                localStorage.setItem(LOCAL_HIGH_SCORE_KEY, newScore);
                highScore = newScore;

                highScoreEl.textContent = highScore.toLocaleString();
                statusMessageEl.textContent = 'NEW RECORD!';
                statusMessageEl.classList.remove('text-red-400', 'text-gray-400', 'text-cyan-400');
                statusMessageEl.classList.add('text-green-400', 'font-bold');

            } catch (error) {
                console.error("Local High score could not be saved:", error);
            }
        }

        function checkAndSaveScore() {
            if (score > highScore) {
                saveHighScore(score);
            }
        }

        // =================================================================
        //                 PROPORTIONAL INPUT LOGIC
        // =================================================================

        function handlePressStart(e) {
             if (!animationFrameId) return; 
            if (isPressing) return;
            
            // Eğer AudioContext başlamadıysa, ilk tıklamayı ses bağlamını başlatmak için kullan
            if (Tone.context.state !== 'running' && isAudioReady) {
                startAudioContext();
            }

            if (e.code === 'Space' || e.type === 'touchstart' || e.type === 'mousedown') {
                isPressing = true;
                pressStartTime = performance.now();
                e.preventDefault(); 
            }
        }

        function handlePressEnd(e) {
            if (!animationFrameId || !isPressing) return;
            
            if (e.code === 'Space' || e.type === 'touchend' || e.type === 'mouseup') {
                const pressDuration = performance.now() - pressStartTime;

                let durationFactor = Math.min(1, 
                    Math.max(0, 
                        (pressDuration - MIN_DURATION_MS) / (MAX_DURATION_MS - MIN_DURATION_MS)
                    )
                );

                const liftForce = MIN_LIFT + durationFactor * (MAX_LIFT - MIN_LIFT);

                orb.velocityY = liftForce;

                isPressing = false;
                e.preventDefault(); 
                
                // Instant feedback sound
                if (isAudioReady && Tone.context.state === 'running') {
                    pressFeedback.triggerAttackRelease("G6", "64n"); 
                }

                if (liftForce < MIN_LIFT) {
                    navigator.vibrate?.(50);
                }
            }
        }


        // --- GAME LOOP, UPDATE, AND DRAW CODE ---

        function resizeCanvas() {
            const containerRect = canvasContainer.getBoundingClientRect();
            
            const padding = 10; 
            const containerWidth = containerRect.width - padding * 2;
            const containerHeight = containerRect.height - padding * 2;
            
            const aspectRatio = 400 / 600; 
            
            let maxWidth = containerWidth;
            let maxHeight = containerHeight;
            
            if (maxWidth / maxHeight > aspectRatio) {
                maxWidth = maxHeight * aspectRatio;
            } else {
                maxHeight = maxWidth / aspectRatio;
            }
            
            canvas.width = Math.floor(maxWidth);
            canvas.height = Math.floor(maxHeight);

            orb.x = canvas.width / 2;
            orb.y = canvas.height - 50;
        }

        /**
         * OYUNU KOŞULSUZ BAŞLATAN FONKSİYON
         */
        function startGame() {
            // Sesi başlatmayı dene
            if (isAudioReady) {
                startAudioContext();
            }
            
            lastTimestamp = performance.now(); 
            
            // Oyun döngüsünü başlat
            if (!animationFrameId) {
                gameLoop();
                statusMessageEl.textContent = 'CATCH THE RHYTHM!';
                statusMessageEl.classList.remove('text-gray-400');
                statusMessageEl.classList.add('text-cyan-400');
            }
        }

        function update() {
            const currentTimestamp = performance.now();
            const deltaTime = currentTimestamp - lastTimestamp;
            lastTimestamp = currentTimestamp;

            // 1. Orb Physics
            orb.velocityY += GRAVITY;
            orb.y += orb.velocityY;

            // 2. Screen Boundaries
            if (orb.y + orb.radius > canvas.height) {
                orb.y = canvas.height - orb.radius;
                orb.velocityY = 0;
            }
            if (orb.y - orb.radius < 0) {
                orb.y = 0 + orb.radius;
                orb.velocityY = 0;
            }

            // 3. Flow Zone Movement
            flowZone.time += flowZone.speed;
            const zoneCenter = (canvas.height / 2) + (Math.sin(flowZone.time) * ZONE_AMPLITUDE);
            flowZone.y = zoneCenter - (flowZone.height / 2); 
            
            if (flowZone.y < 0) flowZone.y = 0;
            if (flowZone.y + flowZone.height > canvas.height) flowZone.y = canvas.height - flowZone.height;

            // 4. "FLOW" CHECK
            const topOfOrb = orb.y - orb.radius;
            const bottomOfOrb = orb.y + orb.radius;
            const topOfZone = flowZone.y;
            const bottomOfZone = flowZone.y + flowZone.height;

            const oldMultiplier = scoreMultiplier;
            const oldCombo = combo;

            if (topOfOrb >= topOfZone && bottomOfOrb <= bottomOfZone) {
                // IN FLOW
                if (!isInFlow) {
                    isInFlow = true;
                    flowDurationMs = 0; 
                    scoreMultiplier = 1;
                    if(isAudioReady && Tone.context.state === 'running') flowPad.triggerAttack(currentFlowNote); 

                    statusMessageEl.textContent = 'FLOW!'; 
                    statusMessageEl.classList.add('text-cyan-400', 'font-bold');
                    statusMessageEl.classList.remove('text-red-400', 'text-gray-400', 'text-green-400');
                    canvas.classList.add('flow-active-shadow'); 
                }
                
                // NEW SCORING: Time-Based Multiplier
                flowDurationMs += deltaTime;
                const secondsInFlow = Math.floor(flowDurationMs / TIME_TICK_MS);
                
                scoreMultiplier = 1 + (secondsInFlow * 2);

                score += scoreMultiplier * (deltaTime / 16.66); 
                
                combo++;
                
                if (scoreMultiplier > oldMultiplier && isAudioReady && Tone.context.state === 'running') {
                    missEffect.triggerAttackRelease("E5", "16n", Tone.now(), 0.5); 
                }

                if (combo % 50 === 0 && combo !== 0 && oldCombo < combo) {
                    comboFlashRadius1 = 10; 
                    comboFlashRadius2 = 1; 
                    if (isAudioReady && Tone.context.state === 'running') {
                        flowPad.triggerAttackRelease("A5", "16n"); 
                    }
                }
                
                // Dynamic Difficulty
                flowZone.speed = Math.min(MAX_ZONE_SPEED, BASE_ZONE_SPEED + (combo * 0.0001));
                flowZone.height = Math.max(MIN_ZONE_HEIGHT, BASE_ZONE_HEIGHT - (combo * 0.05));
                
                // Dynamic Color Cycling & Pitch Modulation
                const baseHue = 180; 
                let hueOffset = (combo % COMBO_COLOR_CYCLE) * (360 / COMBO_COLOR_CYCLE);
                let dynamicHue = (baseHue + hueOffset) % 360;
                
                const minMidi = 60; 
                const maxMidi = 74; 
                const pitchRange = maxMidi - minMidi;
                const maxComboForFullPitch = 300;
                
                let targetMidi = minMidi + Math.min(maxComboForFullPitch, combo) * (pitchRange / maxComboForFullPitch);
                targetMidi = Math.round(targetMidi);
                
                const targetNote = Tone.Midi(targetMidi).toNote();
                
                if (targetNote !== currentFlowNote && isAudioReady && Tone.context.state === 'running') {
                    currentFlowNote = targetNote;
                    flowPad.frequency.rampTo(currentFlowNote, 0.2); 
                }

                const maxComboVisual = 300;
                const saturation = Math.min(100, 30 + (combo / maxComboVisual) * 70); 
                const lightness = Math.max(5, 12 - (combo / maxComboVisual) * 7); 

                document.documentElement.style.setProperty('--bg-hue', dynamicHue);
                document.documentElement.style.setProperty('--bg-saturation', `${saturation}%`);
                document.documentElement.style.setProperty('--bg-lightness', `${lightness}%`);
                
            } else {
                // OUT OF FLOW
                if (isInFlow) {
                    isInFlow = false;
                    checkAndSaveScore(); 
                    combo = 0; 
                    flowDurationMs = 0;
                    scoreMultiplier = 1; // Reset Multiplier
                    comboFlashRadius1 = 0;
                    comboFlashRadius2 = 0;
                    
                    if(isAudioReady && Tone.context.state === 'running') {
                        flowPad.triggerRelease();
                        missEffect.triggerAttackRelease("C2", "8n"); 
                    }
                    
                    currentFlowNote = 'C4'; 
                    flowZone.speed = BASE_ZONE_SPEED;
                    flowZone.height = BASE_ZONE_HEIGHT;
                    
                    statusMessageEl.textContent = 'Rhythm Lost'; 
                    statusMessageEl.classList.remove('text-cyan-400', 'font-bold', 'text-green-400');
                    statusMessageEl.classList.add('text-red-400');
                    canvas.classList.remove('flow-active-shadow');

                    // Reset colors to original state
                    document.documentElement.style.setProperty('--bg-hue', 220); 
                    document.documentElement.style.setProperty('--bg-saturation', '20%');
                    document.documentElement.style.setProperty('--bg-lightness', '8%');

                    setTimeout(() => {
                        if (!isInFlow && score <= highScore) { 
                            statusMessageEl.textContent = 'GET READY!'; 
                            statusMessageEl.classList.remove('text-red-400');
                            statusMessageEl.classList.add('text-cyan-400');
                        }
                    }, 1500);
                }
            }
            
            // Combo Flash Animation
            if (comboFlashRadius1 > 0) {
                comboFlashRadius1 += 8; 
                comboFlashRadius2 += 5; 
                if (comboFlashRadius1 > canvas.width * 0.9) {
                    comboFlashRadius1 = 0;
                    comboFlashRadius2 = 0;
                }
            }

            // Update Score/Combo UI
            scoreEl.textContent = Math.floor(score).toLocaleString(); 
            multiplierEl.textContent = scoreMultiplier; 
        }

        function draw() {
            const flowHue = parseInt(document.documentElement.style.getPropertyValue('--bg-hue')) || 180;
            const isFlowing = isInFlow;
            const currentCombo = combo;
            
            // 1. Ekranı Temizle (Clean Clear)
            ctx.fillStyle = '#0f0c1c'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.globalCompositeOperation = 'lighter'; 

            // Combo Flash Ring
            if (comboFlashRadius1 > 0) {
                const maxRadius = canvas.width * 0.9;
                
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, comboFlashRadius1, 0, Math.PI * 2);
                const alpha1 = 1 - (comboFlashRadius1 / maxRadius);
                ctx.strokeStyle = `hsla(${flowHue}, 100%, 75%, ${alpha1 * 0.9})`; 
                ctx.lineWidth = 6;
                ctx.stroke();
                ctx.closePath();

                if (comboFlashRadius2 > 0) {
                    ctx.beginPath();
                    ctx.arc(orb.x, orb.y, comboFlashRadius2, 0, Math.PI * 2);
                    const alpha2 = 1 - (comboFlashRadius2 / maxRadius);
                    ctx.strokeStyle = `hsla(${flowHue}, 100%, 50%, ${alpha2 * 0.5})`; 
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.closePath();
                }
            }

            // 2. Draw Flow Zone
            ctx.fillStyle = `hsla(${flowHue}, ${isFlowing ? 90 : 50}%, ${isFlowing ? 30 : 20}%, 0.15)`;
            ctx.fillRect(0, flowZone.y - 5, canvas.width, flowZone.height + 10);

            ctx.fillStyle = `hsla(${flowHue}, ${isFlowing ? 100 : 60}%, ${isFlowing ? 40 : 25}%, 0.25)`; 
            ctx.fillRect(0, flowZone.y, canvas.width, flowZone.height);

            ctx.fillStyle = `hsla(${flowHue}, ${isFlowing ? 100 : 70}%, ${isFlowing ? 50 : 35}%, 0.4)`; 
            ctx.fillRect(0, flowZone.y + flowZone.height * 0.15, canvas.width, flowZone.height * 0.7);

            ctx.strokeStyle = `hsla(${flowHue}, ${isFlowing ? 100 : 70}%, ${isFlowing ? 65 : 45}%, 1)`;
            ctx.lineWidth = isFlowing ? 2 : 1;
            ctx.strokeRect(0, flowZone.y, canvas.width, flowZone.height);
            ctx.lineWidth = 1; 

            // 3. Draw Orb 
            const orbColor = isFlowing ? `hsl(${flowHue}, 100%, 75%)` : '#FFFFFF';
            const orbGlowColor = isFlowing ? `hsla(${flowHue}, 100%, 70%, 1)` : 'rgba(255, 255, 255, 0.5)';
            
            ctx.shadowBlur = isFlowing ? 25 : 8;
            ctx.shadowColor = orbGlowColor;
            
            ctx.beginPath();
            ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
            ctx.fillStyle = orbColor;
            ctx.fill();
            ctx.shadowBlur = 0; 
            ctx.closePath();
            
            if (isFlowing) {
                 ctx.beginPath();
                 ctx.arc(orb.x, orb.y, orb.radius * 0.6, 0, Math.PI * 2);
                 ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; 
                 ctx.fill();
                 ctx.closePath();
            }

            if (isFlowing) {
                const auraRadius = orb.radius + 5 + Math.min(10, currentCombo / 30);
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, auraRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${flowHue}, 100%, 60%, ${0.3 + Math.min(0.7, currentCombo/100)})`;
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.closePath();
            }

            ctx.globalCompositeOperation = 'source-over';
        }

        // --- GAME LOOP ---
        function gameLoop() {
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // =================================================================
        //                       INITIALIZATION AND EVENT LISTENERS
        // =================================================================

        window.onload = function() {
            loadHighScore(); 
            setupAudio();
            resizeCanvas();
            
            // OYUN DİREKT BAŞLIYOR!
            startGame(); 

            // Olay dinleyicilerini kur
            window.addEventListener('keydown', handlePressStart);
            window.addEventListener('keyup', handlePressEnd);

            canvas.addEventListener('mousedown', handlePressStart);
            window.addEventListener('mouseup', handlePressEnd);
            
            canvas.addEventListener('touchstart', handlePressStart);
            window.addEventListener('touchend', handlePressEnd);

            window.addEventListener('resize', resizeCanvas);
        };

    </script>
</body>
</html>
