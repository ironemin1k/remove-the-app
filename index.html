<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remove the app! (Local)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.58/build/Tone.min.js"></script>
    <style>
        /* CSS Variables for Dynamic Background Control */
        :root {
            --bg-hue: 220; 
            --bg-saturation: 20%;
            --bg-lightness: 8%;
        }
        body {
            /* TAM EKRAN İÇİN DÜZENLENDİ: Ekranın tamamını kapla */
            width: 100vw; 
            height: 100vh;
            margin: 0;
            padding: 0;
            
            /* HSL used for dynamic hue cycling */
            background: radial-gradient(circle at center, 
                hsl(var(--bg-hue), var(--bg-saturation), 10%) 0%, 
                #000000 100%);
            transition: background 0.5s ease-out; 
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; 
        }
        #gameCanvas {
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2), 0 0 10px rgba(0, 255, 255, 0.4);
            border: 2px solid #00FFFF;
            transition: box-shadow 0.3s ease-out;
            cursor: pointer; 
        }
        .flow-active-shadow {
            /* Dynamic glow based on current hue for aesthetics */
            box-shadow: 0 0 100px hsla(var(--bg-hue), 100%, 70%, 0.9), 0 0 30px hsla(var(--bg-hue), 100%, 80%, 1);
            border: 3px solid hsla(var(--bg-hue), 100%, 80%, 1) !important;
        }
        /* Ekranın tamamını kaplamak için ana kapsayıcıya gerekli ayarlar */
        .full-screen-container {
             width: 100%;
             height: 100%;
             flex-grow: 1; /* Esnekliği koru */
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Consolas', 'Monaco', 'monospace'],
                    },
                }
            }
        }
    </script>
</head>
<body class="flex flex-col items-center justify-start min-h-screen pt-4 pb-4 overflow-hidden text-gray-100">

    <div class="text-4xl font-extrabold mb-4 tracking-widest text-red-400">
        <span class="text-gray-500">REMOVE </span><span class="text-red-500">THE APP!</span>
    </div>

    <div class="grid grid-cols-3 gap-4 mb-4 p-4 bg-gray-900/70 backdrop-blur-md rounded-2xl shadow-2xl border border-cyan-800/50 w-full max-w-lg">
        <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
            Score: <span id="score" class="text-yellow-300 font-extrabold text-xl font-mono">0</span>
        </div>
        <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
            Multiplier: <span id="multiplier" class="text-orange-400 font-extrabold text-xl font-mono">1</span>x
        </div>
        <div class="text-sm font-medium text-center border-b border-gray-700/50 pb-1">
            High: <span id="highScore" class="text-green-400 font-extrabold text-xl font-mono">0</span>
        </div>
        <div id="statusMessage" class="col-span-3 text-sm font-medium text-center border-b border-gray-700/50 pb-1 text-gray-400 transition duration-300">
            Waiting...
        </div>
    </div>
    
    <div id="audioContextContainer" class="absolute inset-0 bg-gray-900/95 flex items-center justify-center z-20 transition duration-500">
        <button id="audioContextButton" class="bg-red-600 hover:bg-red-500 text-white font-bold py-4 px-8 rounded-full shadow-2xl shadow-red-500/50 transform transition duration-150 active:scale-95 text-xl tracking-widest">
            START THE GAME
        </button>
    </div>

    <div class="full-screen-container flex items-center justify-center">
        <canvas id="gameCanvas" class="rounded-xl"></canvas>
    </div>

    <div class="mt-4 text-sm text-gray-500">
        <span class="font-bold text-yellow-400">Tip:</span> Jump power is proportional to your press duration.
    </div>

    <script>
        // *** DİKKAT: TÜM HARİCİ API IMPORT'LARI (FIREBASE, GEMINI) KALDIRILDI ***
        
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const multiplierEl = document.getElementById('multiplier'); 
        const highScoreEl = document.getElementById('highScore');
        const statusMessageEl = document.getElementById('statusMessage');
        const audioContextContainer = document.getElementById('audioContextContainer');
        const audioContextButton = document.getElementById('audioContextButton');

        // --- GAME SETTINGS ---
        const ORB_RADIUS = 15;
        const GRAVITY = 0.4;
        
        // --- PROPORTIONAL INPUT SETTINGS ---
        const MIN_LIFT = -3;   
        const MAX_LIFT = -13;  
        const MIN_DURATION_MS = 30; 
        const MAX_DURATION_MS = 200; 
        let pressStartTime = 0; 
        let isPressing = false; 

        // --- FLOW ZONE SETTINGS ---
        const BASE_ZONE_HEIGHT = 150;
        const MIN_ZONE_HEIGHT = 40; 
        const BASE_ZONE_SPEED = 0.03;
        const MAX_ZONE_SPEED = 0.08; 
        const ZONE_AMPLITUDE = 150;
        const COMBO_COLOR_CYCLE = 200; 
        const TIME_TICK_MS = 1000; 

        // --- GAME OBJECTS AND STATE ---
        let orb = { x: 0, y: 0, radius: ORB_RADIUS, velocityY: 0 };
        let flowZone = { y: 0, height: BASE_ZONE_HEIGHT, speed: BASE_ZONE_SPEED, time: 0 };
        let score = 0;
        let combo = 0;
        let isInFlow = false;
        let isAudioReady = false;
        let animationFrameId;
        let comboFlashRadius1 = 0; 
        let comboFlashRadius2 = 0; 

        // --- SCORING STATE ---
        let flowDurationMs = 0; 
        let scoreMultiplier = 1;

        // --- LOKAL YÜKSEK SKOR (LocalStorage) ---
        let highScore = 0;
        const LOCAL_HIGH_SCORE_KEY = 'flowGameHighScore'; 
        
        // --- TONE.JS AUDIO OBJECTS ---
        let flowPad, missEffect, pressFeedback;
        let currentFlowNote = 'C4'; 

        // --- Timing Variables for accurate scoring ---
        let lastTimestamp = performance.now();


        // =================================================================
        //                 AUDIO (TONE.JS) INTEGRATION
        // =================================================================

        function setupAudio() {
            if (typeof Tone === 'undefined') {
                return;
            }

            // 1. Flow Pad (Continuous, Pitching Up Sound)
            flowPad = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.5, decay: 0.1, sustain: 1.0, release: 0.5 },
                volume: -15, 
            }).toDestination();
            
            // 2. Miss Effect (Low, Punchy and Resolving Sound)
            missEffect = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 3,
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.5 },
                volume: -8
            }).toDestination();

            // 3. Press Feedback (High-frequency, soft click)
            pressFeedback = new Tone.PluckSynth({
                attackNoise: 1,
                dampening: 2000,
                resonance: 0.9,
                volume: 0, 
            }).toDestination();

            isAudioReady = true;
        }

        async function startAudioContext() {
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                } catch (e) {
                    console.error("Tone.start() error:", e);
                }
            }
            audioContextContainer.classList.add('hidden');
        }

        // =================================================================
        //                 LOKAL SKOR KAYIT/YÜKLEME (LocalStorage)
        // =================================================================

        function loadHighScore() {
            try {
                const storedScore = localStorage.getItem(LOCAL_HIGH_SCORE_KEY);
                highScore = storedScore ? parseInt(storedScore, 10) : 0;
            } catch (error) {
                console.error("Local High score could not be loaded:", error);
                highScore = 0;
            }
            highScoreEl.textContent = highScore.toLocaleString();
        }

        function saveHighScore(newScore) {
            if (newScore <= highScore) return;

            try {
                localStorage.setItem(LOCAL_HIGH_SCORE_KEY, newScore);
                highScore = newScore;

                highScoreEl.textContent = highScore.toLocaleString();
                statusMessageEl.textContent = 'NEW RECORD!';
                statusMessageEl.classList.remove('text-red-400', 'text-gray-400', 'text-cyan-400');
                statusMessageEl.classList.add('text-green-400', 'font-bold');

            } catch (error) {
                console.error("Local High score could not be saved:", error);
            }
        }

        function checkAndSaveScore() {
            if (score > highScore) {
                saveHighScore(score);
            }
        }

        // =================================================================
        //                 PROPORTIONAL INPUT LOGIC
        // =================================================================

        function handlePressStart(e) {
            // Klavye kontrolü için sadece 'Space' tuşu, fare/dokunmatik için 'mousedown'/'touchstart'
            if (!animationFrameId) return; 
            if (isPressing) return;
            
            if (e.code === 'Space' || e.type === 'touchstart' || e.type === 'mousedown') {
                isPressing = true;
                pressStartTime = performance.now();
                e.preventDefault(); 
            }
        }

        function handlePressEnd(e) {
            // Klavye kontrolü için sadece 'Space' tuşu, fare/dokunmatik için 'mouseup'/'touchend'
            if (!animationFrameId || !isPressing) return;
            
            if (e.code === 'Space' || e.type === 'touchend' || e.type === 'mouseup') {
                const pressDuration = performance.now() - pressStartTime;

                let durationFactor = Math.min(1, 
                    Math.max(0, 
                        (pressDuration - MIN_DURATION_MS) / (MAX_DURATION_MS - MIN_DURATION_MS)
                    )
                );

                const liftForce = MIN_LIFT + durationFactor * (MAX_LIFT - MIN_LIFT);

                orb.velocityY = liftForce;

                isPressing = false;
                e.preventDefault(); 
                
                // Instant feedback sound
                if (isAudioReady) {
                    pressFeedback.triggerAttackRelease("G6", "64n"); 
                }

                if (liftForce < MIN_LIFT) {
                    navigator.vibrate?.(50);
                }
            }
        }


        // --- GAME LOOP, UPDATE, AND DRAW CODE ---

        function resizeCanvas() {
            // TAM EKRAN İÇİN GÜNCELLENDİ: Maksimum kısıtları kaldırıp, kapsayıcının tamamını kullan
            const container = document.querySelector('.full-screen-container');
            if (container) {
                const containerRect = container.getBoundingClientRect();
                
                // Canvas'ı dikey ve yatayda daha küçük olana göre kare veya dikeydörtgen tutmak için bir oran belirleyebiliriz.
                // Örneğin, 2:3 oranı korunsun (genişlik 400, yükseklik 600)
                const aspectRatio = 400 / 600;
                
                // Kapsayıcıdaki mevcut boşluğa göre maksimum genişlik ve yüksekliği hesapla
                let maxWidth = containerRect.width;
                let maxHeight = containerRect.height;
                
                // Max genişlik, max yüksekliğe uymalı
                if (maxWidth / maxHeight > aspectRatio) {
                    // Genişlik çok fazla, yüksekliği sınırla
                    maxWidth = maxHeight * aspectRatio;
                } else {
                    // Yükseklik çok fazla, genişliği sınırla
                    maxHeight = maxWidth / aspectRatio;
                }
                
                // Boyutları ayarlarken biraz boşluk bırak (isteğe bağlı)
                const padding = 20; 
                canvas.width = Math.floor(maxWidth - padding);
                canvas.height = Math.floor(maxHeight - padding);
            } else {
                // Yedek değerler
                canvas.width = 400; 
                canvas.height = 600;
            }

            // Orb pozisyonunu merkeze çek
            orb.x = canvas.width / 2;
            orb.y = canvas.height - 50;
        }

        function startGame() {
            startAudioContext(); 
            
            audioContextButton.removeEventListener('click', startGame);
            audioContextButton.removeEventListener('touchstart', startGame);
            
            if (!animationFrameId) {
                // Initialize lastTimestamp before starting the loop for delta time calculation
                lastTimestamp = performance.now(); 
                gameLoop();
                statusMessageEl.textContent = 'CATCH THE RHYTHM!';
            }
        }

        function update() {
            const currentTimestamp = performance.now();
            const deltaTime = currentTimestamp - lastTimestamp;
            lastTimestamp = currentTimestamp;

            // 1. Orb Physics
            orb.velocityY += GRAVITY;
            orb.y += orb.velocityY;

            // 2. Screen Boundaries
            if (orb.y + orb.radius > canvas.height) {
                orb.y = canvas.height - orb.radius;
                orb.velocityY = 0;
            }
            if (orb.y - orb.radius < 0) {
                orb.y = 0 + orb.radius;
                orb.velocityY = 0;
            }

            // 3. Flow Zone Movement
            flowZone.time += flowZone.speed;
            const zoneCenter = (canvas.height / 2) + (Math.sin(flowZone.time) * ZONE_AMPLITUDE);
            flowZone.y = zoneCenter - (flowZone.height / 2); 
            
            if (flowZone.y < 0) flowZone.y = 0;
            if (flowZone.y + flowZone.height > canvas.height) flowZone.y = canvas.height - flowZone.height;

            // 4. "FLOW" CHECK
            const topOfOrb = orb.y - orb.radius;
            const bottomOfOrb = orb.y + orb.radius;
            const topOfZone = flowZone.y;
            const bottomOfZone = flowZone.y + flowZone.height;

            const oldMultiplier = scoreMultiplier;

            if (topOfOrb >= topOfZone && bottomOfOrb <= bottomOfZone) {
                // IN FLOW
                if (!isInFlow) {
                    isInFlow = true;
                    flowDurationMs = 0; 
                    scoreMultiplier = 1;
                    if(isAudioReady) flowPad.triggerAttack(currentFlowNote); 

                    statusMessageEl.textContent = 'FLOW!'; 
                    statusMessageEl.classList.add('text-cyan-400', 'font-bold');
                    statusMessageEl.classList.remove('text-red-400', 'text-gray-400', 'text-green-400');
                    canvas.classList.add('flow-active-shadow'); 
                }
                
                // NEW SCORING: Time-Based Multiplier
                flowDurationMs += deltaTime;
                const secondsInFlow = Math.floor(flowDurationMs / TIME_TICK_MS);
                
                // Multiplier increases by +2x every second (1x, 3x, 5x, 7x...)
                scoreMultiplier = 1 + (secondsInFlow * 2);

                // Add score based on the multiplier (Base Score: 1 per frame)
                // Score = 1 (base) * scoreMultiplier * (deltaTime / 16.66ms)
                // Basitlik için: score += scoreMultiplier
                 score += scoreMultiplier * (deltaTime / 16.66); // Delta time ile daha akıcı skor

                // Combo count is still useful for visual/difficulty scaling
                combo++;
                
                // Check if multiplier just ticked up (for visual/audio confirmation)
                if (scoreMultiplier > oldMultiplier && isAudioReady) {
                    // Play a distinct chime for multiplier increase
                    missEffect.triggerAttackRelease("E5", "16n", Tone.now(), 0.5); 
                }

                // NEW: Trigger visual flash on combo milestones (kept this for visual excitement)
                if (combo % 50 === 0 && combo !== 0) {
                    comboFlashRadius1 = 10; 
                    comboFlashRadius2 = 1; 
                    if (isAudioReady) {
                        flowPad.triggerAttackRelease("A5", "16n"); 
                    }
                }
                
                // Dynamic Difficulty (scales with linear combo)
                flowZone.speed = Math.min(MAX_ZONE_SPEED, BASE_ZONE_SPEED + (combo * 0.0001));
                flowZone.height = Math.max(MIN_ZONE_HEIGHT, BASE_ZONE_HEIGHT - (combo * 0.05));
                
                // Dynamic Color Cycling & Pitch Modulation (remains the same)
                const baseHue = 180; 
                let hueOffset = (combo % COMBO_COLOR_CYCLE) * (360 / COMBO_COLOR_CYCLE);
                let dynamicHue = (baseHue + hueOffset) % 360;
                
                const minMidi = 60; 
                const maxMidi = 74; 
                const pitchRange = maxMidi - minMidi;
                const maxComboForFullPitch = 300;
                
                let targetMidi = minMidi + Math.min(maxComboForFullPitch, combo) * (pitchRange / maxComboForFullPitch);
                targetMidi = Math.round(targetMidi);
                
                const targetNote = Tone.Midi(targetMidi).toNote();
                
                if (targetNote !== currentFlowNote && isAudioReady) {
                    currentFlowNote = targetNote;
                    flowPad.frequency.rampTo(currentFlowNote, 0.2); 
                }

                const maxComboVisual = 300;
                const saturation = Math.min(100, 30 + (combo / maxComboVisual) * 70); 
                const lightness = Math.max(5, 12 - (combo / maxComboVisual) * 7); 

                document.documentElement.style.setProperty('--bg-hue', dynamicHue);
                document.documentElement.style.setProperty('--bg-saturation', `${saturation}%`);
                document.documentElement.style.setProperty('--bg-lightness', `${lightness}%`);
                
            } else {
                // OUT OF FLOW
                if (isInFlow) {
                    isInFlow = false;
                    checkAndSaveScore(); 
                    combo = 0; 
                    flowDurationMs = 0;
                    scoreMultiplier = 1; // Reset Multiplier
                    comboFlashRadius1 = 0;
                    comboFlashRadius2 = 0;
                    
                    if(isAudioReady) {
                        flowPad.triggerRelease();
                        missEffect.triggerAttackRelease("C2", "8n"); 
                    }
                    
                    currentFlowNote = 'C4'; 
                    flowZone.speed = BASE_ZONE_SPEED;
                    flowZone.height = BASE_ZONE_HEIGHT;
                    
                    statusMessageEl.textContent = 'Rhythm Lost'; 
                    statusMessageEl.classList.remove('text-cyan-400', 'font-bold', 'text-green-400');
                    statusMessageEl.classList.add('text-red-400');
                    canvas.classList.remove('flow-active-shadow');

                    // Reset colors to original state
                    document.documentElement.style.setProperty('--bg-hue', 220); 
                    document.documentElement.style.setProperty('--bg-saturation', '20%');
                    document.documentElement.style.setProperty('--bg-lightness', '8%');

                    setTimeout(() => {
                        if (!isInFlow && score <= highScore) { 
                            statusMessageEl.textContent = 'Waiting...'; 
                            statusMessageEl.classList.remove('text-red-400');
                            statusMessageEl.classList.add('text-gray-400');
                        }
                    }, 1500);
                }
            }
            
            // Combo Flash Animation
            if (comboFlashRadius1 > 0) {
                comboFlashRadius1 += 8; 
                comboFlashRadius2 += 5; 
                if (comboFlashRadius1 > canvas.width * 0.9) {
                    comboFlashRadius1 = 0;
                    comboFlashRadius2 = 0;
                }
            }

            // Update Score/Combo UI
            scoreEl.textContent = Math.floor(score).toLocaleString(); // Skoru tam sayı gösterelim
            multiplierEl.textContent = scoreMultiplier; 
        }

        // --- DRAWING (DRAW) ---
        function draw() {
            const flowHue = parseInt(document.documentElement.style.getPropertyValue('--bg-hue')) || 180;
            const isFlowing = isInFlow;
            const currentCombo = combo;
            
            // 1. Ekranı Temizle (Clean Clear)
            ctx.fillStyle = '#0f0c1c'; // Deep, near-black clear
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Set composite operation for additive blending (better glow effect)
            ctx.globalCompositeOperation = 'lighter'; 

            // Combo Flash Ring (Product Level - Two Rings)
            if (comboFlashRadius1 > 0) {
                const maxRadius = canvas.width * 0.9;
                
                // Ring 1 (Inner, faster decay)
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, comboFlashRadius1, 0, Math.PI * 2);
                const alpha1 = 1 - (comboFlashRadius1 / maxRadius);
                ctx.strokeStyle = `hsla(${flowHue}, 100%, 75%, ${alpha1 * 0.9})`; 
                ctx.lineWidth = 6;
                ctx.stroke();
                ctx.closePath();

                // Ring 2 (Outer, trailing, softer)
                if (comboFlashRadius2 > 0) {
                    ctx.beginPath();
                    ctx.arc(orb.x, orb.y, comboFlashRadius2, 0, Math.PI * 2);
                    const alpha2 = 1 - (comboFlashRadius2 / maxRadius);
                    ctx.strokeStyle = `hsla(${flowHue}, 100%, 50%, ${alpha2 * 0.5})`; 
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.closePath();
                }
            }


            // 2. Draw Flow Zone (Layered Energy Field Effect)
            
            // Outer Layer (Soft Glow)
            ctx.fillStyle = `hsla(${flowHue}, ${isFlowing ? 90 : 50}%, ${isFlowing ? 30 : 20}%, 0.15)`;
            ctx.fillRect(0, flowZone.y - 5, canvas.width, flowZone.height + 10);

            // Middle Layer (Intense Field)
            ctx.fillStyle = `hsla(${flowHue}, ${isFlowing ? 100 : 60}%, ${isFlowing ? 40 : 25}%, 0.25)`; 
            ctx.fillRect(0, flowZone.y, canvas.width, flowZone.height);

            // Inner Layer (Central Flow)
            ctx.fillStyle = `hsla(${flowHue}, ${isFlowing ? 100 : 70}%, ${isFlowing ? 50 : 35}%, 0.4)`; 
            ctx.fillRect(0, flowZone.y + flowZone.height * 0.15, canvas.width, flowZone.height * 0.7);

            // Border Lines
            ctx.strokeStyle = `hsla(${flowHue}, ${isFlowing ? 100 : 70}%, ${isFlowing ? 65 : 45}%, 1)`;
            ctx.lineWidth = isFlowing ? 2 : 1;
            ctx.strokeRect(0, flowZone.y, canvas.width, flowZone.height);
            ctx.lineWidth = 1; 

            // 3. Draw Orb (Ethereal Orb)
            
            // Dynamic Brightness Colors
            const orbColor = isFlowing ? `hsl(${flowHue}, 100%, 75%)` : '#FFFFFF';
            const orbGlowColor = isFlowing ? `hsla(${flowHue}, 100%, 70%, 1)` : 'rgba(255, 255, 255, 0.5)';
            
            // Shadow Effect (Glow)
            ctx.shadowBlur = isFlowing ? 25 : 8;
            ctx.shadowColor = orbGlowColor;
            
            // Draw Orb
            ctx.beginPath();
            ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
            ctx.fillStyle = orbColor;
            ctx.fill();
            ctx.shadowBlur = 0; 
            ctx.closePath();
            
            // Inner Light (Orb center)
            if (isFlowing) {
                 ctx.beginPath();
                 ctx.arc(orb.x, orb.y, orb.radius * 0.6, 0, Math.PI * 2);
                 ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // Parlak beyaz merkez
                 ctx.fill();
                 ctx.closePath();
            }

            // Outer Aura Ring (Combo-dependent)
            if (isFlowing) {
                const auraRadius = orb.radius + 5 + Math.min(10, currentCombo / 30);
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, auraRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${flowHue}, 100%, 60%, ${0.3 + Math.min(0.7, currentCombo/100)})`;
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.closePath();
            }

            // Reset composite operation to default
            ctx.globalCompositeOperation = 'source-over';
        }

        // --- GAME LOOP ---
        function gameLoop() {
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // =================================================================
        //                       INITIALIZATION AND EVENT LISTENERS
        // =================================================================

        window.onload = function() {
            // initFirebase yerine lokal skor yükleme
            loadHighScore(); 
            setupAudio();
            resizeCanvas();

            audioContextButton.addEventListener('click', startGame);
            audioContextButton.addEventListener('touchstart', startGame);
            
            window.addEventListener('keydown', handlePressStart);
            window.addEventListener('keyup', handlePressEnd);

            canvas.addEventListener('mousedown', handlePressStart);
            window.addEventListener('mouseup', handlePressEnd);
            
            canvas.addEventListener('touchstart', handlePressStart);
            window.addEventListener('touchend', handlePressEnd);

            // Ekran boyutlandığında canvas boyutunu da güncelle
            window.addEventListener('resize', resizeCanvas);
        };

    </script>
</body>
</html>